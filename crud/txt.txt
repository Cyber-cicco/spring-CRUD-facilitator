Coucou, si y en a qui font encore du Spring, j'ai créé un petit script qui permet de créer automatiquement des classes dans Spring en utilisant Lombok, Mapstruct
et Spring JPA.
Ça demande d'avoir déjà initialisé un projet Spring, et de copier les fichiers python dans le même dossier que le pom.xml (pour l'instant)
Vous lancez le script avec python dans le terminal, et vous préciser le nom de votre classe, le package de votre projet, le type de classe que vous voulez et ça
vous génère le code de base de la classe.
Donc imaginez si vous avez un projet spring avec une arobrescence src/main/java
Si vous tappez : 
    python3 spring.py -cname Test --controller --package fr.cicco.crud

ça vous crée ça:
```java
package fr.cicco.crud.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
@RequestMapping("api/v1/test")
public class TestController {

}
```
Mais le plus intéressant, c'est si vous utilisez la commande:

python3 spring.py -cname Test1 Test2 Test3 -pck fr.cicco.crud -a --crud

ça vous crée un controller, un service, une entité, un dto, un mapper et un repository pour chaque classe, et le controller de Test2 ressemble à ça:
```java
package fr.cicco.crud.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import fr.cicco.crud.dto.Test1Dto;
import org.springframework.http.ResponseEntity;
import fr.cicco.crud.entity.Test1;
import fr.cicco.crud.service.Test1Service;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
        

@RestController
@RequiredArgsConstructor
@RequestMapping("api/v1/test1")
public class Test1Controller {
   
    private final Test1Service test1service;

    @GetMapping("all")
    public ResponseEntity<List<Test1>> getAllTest1(){
        return ResponseEntity.ok(test1service.findAll());
    }

    @GetMapping("/{id}")
    public ResponseEntity<Test1Dto> getTest1(@PathVariable Long id){
        return ResponseEntity.ok(test1service.find(id));
    }

    @PostMapping
    public ResponseEntity<Test1Dto> saveTest1(@RequestBody Test1Dto dto){
        return ResponseEntity.ok(test1service.save(dto));
    }

    @PatchMapping("/{id}")
    public ResponseEntity<Test1Dto> changeA(@PathVariable Long id, @RequestBody Test1Dto dto){
        return ResponseEntity.ok(test1service.change(id, dto));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Map<String, String>> deleteTest1(@PathVariable Long id){
        return ResponseEntity.ok(test1service.delete(id));
    }
        
}
        
        
```
Le service ressemble à ça:

```
package fr.cicco.crud.service;

import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.validation.annotation.Validated;
import fr.cicco.crud.dto.Test2Dto;
import fr.cicco.crud.mapper.Test2Mapper;
import fr.cicco.crud.entity.Test2;
import fr.cicco.crud.repository.Test2Repository;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
        

@Service
@Validated
@RequiredArgsConstructor
public class Test2Service {

    private final Test2Repository test2repository;
    private final Test2Mapper test2mapper;

    public List<Test2> findAll() {
        return test2repository.findAll();
    }

    public Test2Dto find(Long id) {
        //TODO change type of exception with custom exception. Add exception handler
        return test2mapper.toTest2Dto(test2repository.findById(id).orElseThrow(RuntimeException::new));
    }
    
    public Test2Dto save(Test2Dto test2Dto) {
        test2repository.save(test2mapper.toTest2(test2Dto));
        return test2Dto;
    }
    
    public Test2Dto change(Long id, Test2Dto test2Dto) {
        //TODO implement logic. For now, it throws a NullPointerException
        return null;
    }
    
    public Map<String, String> delete(Long id) {
        //TODO customiser le message de réponse
        Map<String, String> response = new HashMap<>();
        response.put("message", "entity has been deleted");
        test2repository.deleteById(id);
        return response;
    }
        
}
̀̀̀̀``` 
Et le mapper a les méthodes de base d'implémentées. Donc si vous avez cinq entités à créer, ça crée cinq services, cinq repos, cinq dtos, etc. en une ligne de commande
Évidemment faut customiser un peu les classes pour avoir quelque chose qui correspond bien à la logique de votre application, mais ça donne une bonne base qui permet de 
pas avoir à réécrire cent fois la même chose.
Vous pouvez aussi choisir d'implémenter juste un composant, un service, etc. avec les différentes options de la ligne de commande.

Vous avez plusieurs options:

  -h, --help            montrer l'aide
  -cname CLASS_NAME [CLASS_NAME ...], le nom de votre ou vos classes. Vous pouvez en mettre plusieurs à la suite pour toutes les créer
  -pck PACKAGE, --package PACKAGE
                        Le nom du package (exemple : "com.example.mypackage")
  -a, --all             Crées tous les types de classe pour le nom de la classe
  -ctrl, --controller   Crée le controller
  -srv, --service       Crée le service
  -m, --mapper          Crée le mapper mapstruct
  -rep, --repository    Crée le JPA Repository en utilisant un Long comme clé primaire
  -e, --entity          Crée une entité
  -c, --crud            permet de créer de méthodes de base pour gérer les opérations de créer, récupérer, changer et supprimer les entités
  -dto, --dto           Crée un dto pour l'entité

Je garantie pas l'absence de bugs, ça marche que si vous avez un projet Spring avec les dépendances lombok mapstruct (avec la partie dans les plugins qui permet de gérer leur interaction) et JPA et que vous avez copié les fichiers au bon endroit,
et y a encore plein de fonctionalités à implémenter, comme la possibilité d'implémenter ses paramètres dans les entités, pouvoir choisir son package en fonction du type
 mais c'est que le début. Aussi, si un truc vous déplait dans la construction du controller ou autre, vous pouvez assez facilement customiser le script python.